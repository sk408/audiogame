<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Audiogram Game by Stephen Kanney</title>
    <style>
        .canvas-container {
            margin: 0 20px;
            /* Adjust the spacing between canvases */
        }

        body {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        #gridCanvas1,
        #gridCanvas2 {
            border: 1px solid black;
            /* width: 25%; */
            /* height: 80%; */
        }

        @keyframes flash {
            0% {

                background-color: transparent;
            }

            50% {

                background-color: rgb(11, 154, 193);
            }

            100% {
                background-color: transparent;
            }
        }

        #decibelIndicator1.flashing,
        #decibelIndicator2.flashing {
            animation: flash 0.6s infinite;
            background-color: rgb(46, 158, 228);
        }

        .flashing {
            animation: flash 0.2s infinite;
        }

        #randomButton1.lightUp,
        #randomButton2.lightUp {
            background-color: #00ff00;
            /* Change this to the color you want */
        }

        @media (max-width: 900px) {
            canvas {
            font-size: 8px;
                width: 50vw;
                height: 47.5vh;
                /* Adjusted to leave 5% for buttons */
            }
        }

        body {
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            user-select: none;

        }
    </style>

</head>

<body oncontextmenu="return false;">
    <!-- <button onclick="getAudioOutputs()">Get Audio Outputs</button><br>
<select id="audioOutputs"></select><br> -->
    <div id="instructions">Double click or press S to store threshold.<br>Thresholds are randomly generated each load.<br>Use your mouse
        to present tones. </div>
    <div class="canvas-container">

        <canvas id="gridCanvas1"></canvas>
        <div id="scoreDisplay1">Score: 0</div>
        <button id="decibelIndicator1">Decibel Level: N/A</button>
        <button id="randomButton1">Response</button>
        <button id="drawAudiogram">Draw Audiogram</button>
        <br>
        <button onclick="updateGrid('1')" style="display: none;">Update Grid</button>
    </div>
    <div id="canvasContainer2" class="canvas-container">

        <canvas id="gridCanvas2"></canvas>
        <div id="scoreDisplay2">Score: 0</div>
        <button id="decibelIndicator2">Decibel Level: N/A</button>
        <button id="randomButton2">Response</button> <br>

        <button onclick="updateGrid('2')" style="display:none;">Update Grid</button>
        <input type="hidden" id="lastCanvas" value="">
    </div>
    <script>
        async function getAudioOutputs() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioDevices = devices.filter(device => device.kind === 'audiooutput');
                audioDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label;
                    document.getElementById('audioOutputs').appendChild(option);
                });
            } catch (err) {
                console.error(err);
            }
        }

        function setAudioOutput(audioElement, deviceId) {
            if (typeof audioElement.sinkId !== 'undefined') {
                audioElement.setSinkId(deviceId)
                    .then(() => {
                        console.log(`Success, audio output device attached: ${deviceId}`);
                    })
                    .catch(error => {
                        let errorMessage = error;
                        if (error.name === 'SecurityError') {
                            errorMessage = `You need to use HTTPS for selecting audio output device: ${error}`;
                        }
                        console.error(errorMessage);
                    });
            } else {
                console.warn('Browser does not support output device selection.');
            }
        }
        if (window.innerWidth <= 900) {
            includeCanvasLogic(1, "#00f", 12, 13);
            document.getElementById('canvasContainer2').style.display = 'none';
            document.getElementById('instructions').style.display = 'none';
            
        } else {
            includeCanvasLogic(1, "#00f", 12, 13);
            includeCanvasLogic(2, "#f00", 12, 13);
        }
        // includeCanvasLogic(1, "#00f", 12, 13);
        // includeCanvasLogic(2, "#f00", 12, 13);
        // Disable long-press context menu
        document.addEventListener('touchstart', function (event) {
            event.preventDefault();
        });
        document.addEventListener('contextmenu', function (event) {
            event.preventDefault();
        });
        function includeCanvasLogic(canvasId, color, numSquaresX, numSquaresY) {
            console.log("Canvas logic included for canvas ID:", canvasId);
            const canvas = document.getElementById(`gridCanvas${canvasId}`);
            const ctx = canvas.getContext('2d');
            let lastX, lastY;

            let keepX;
            const dotRadius = 8;
            let dots = []; // Array to store the dots
            let gridSizeX, gridSizeY;
            if (window.innerWidth <= 900) {
                // For mobile devices
                canvas.width = window.innerWidth / 2;
                canvas.height = window.innerHeight * 0.475; // Adjusted to leave 5% for buttons
            } else {
                // For desktop
                canvas.width = window.innerWidth / 3;
                canvas.height = window.innerHeight * 0.8;
            }
            function redrawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

                const frequencies = [0, 125, 250, 500, 750, 1000, 1500, 2000, 3000, 4000, 6000, 8000];
                const decibels = Array.from({ length: canvas.height / gridSizeY + 1 }, (_, i) => -10 + i * 10);
                const decibelsHalf = Array.from({ length: canvas.height / (gridSizeY / 2) + 1 }, (_, i) => -10 + i * 5); // 5 decibel increments
                ctx.fillStyle = color;
                if (window.innerWidth <= 900) {
                    ctx.font = "9px Arial";
                } else {
                    ctx.font = "16px Arial";
                }
                for (let i = 0; i <= frequencies.length; i++) {
                    const x = i * gridSizeX;
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    if(frequencies[i]>0)
                    ctx.fillText(frequencies[i] + "hz" || '', x + 5, 15); // Draw the frequency label
                }
                for (let i = 0; i <= decibels.length; i++) {
                    const y = i * gridSizeY;
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    if(decibels[i])
                    ctx.fillText(decibels[i] + "dB" || '', 5, y - 5); // Draw the decibel label
                }
                for (let i = 0; i <= decibelsHalf.length; i++) {
                    const y = i * (gridSizeY / 2);
                    // Don't draw the grid line, just the label
                    // ctx.fillText(decibelsHalf[i] + "dB" || '', 5, y - 5); // Draw the decibel label
                }
                ctx.strokeStyle = "#ddd";
                ctx.stroke();

                // Redraw the dots
                for (let dot of dots) {
                    const x = frequencies.indexOf(dot.frequency) * gridSizeX;
                    const y = ((dot.decibels + 10) / 5) * (gridSizeY / 2);
                    drawDot(x, y);
                }
                dots.sort((a, b) => a.frequency - b.frequency);
                for (let i = 0; i < dots.length - 1; i++) {
                    const x1 = frequencies.indexOf(dots[i].frequency) * gridSizeX;
                    const y1 = ((dots[i].decibels + 10) / 5) * (gridSizeY / 2);
                    const x2 = frequencies.indexOf(dots[i + 1].frequency) * gridSizeX;
                    const y2 = ((dots[i + 1].decibels + 10) / 5) * (gridSizeY / 2);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = '#000'; // Set the line color
                    ctx.stroke();
                }
                drawReticle();
                // ctx.beginPath();
                // ctx.arc(lastX, lastY, 10, 0, 2 * Math.PI);
                // ctx.moveTo(lastX - 15, lastY);
                // ctx.lineTo(lastX + 15, lastY);
                // ctx.moveTo(lastX, lastY - 15);
                // ctx.lineTo(lastX, lastY + 15);
                // ctx.strokeStyle = 'red';
                // ctx.stroke();


            }
            let dotColor = color; // Default dot color
            redrawCanvas();
            updateGrid();
            function drawReticle() {
                ctx.beginPath();
                ctx.arc(lastX, lastY, 10, 0, 2 * Math.PI);
                ctx.moveTo(lastX - 15, lastY);
                ctx.lineTo(lastX + 15, lastY);
                ctx.moveTo(lastX, lastY - 15);
                ctx.lineTo(lastX, lastY + 15);
                ctx.strokeStyle = 'red';
                ctx.stroke();

            }
            window.addEventListener('keydown', function (e) {
                
                frequencyX = coordinatesToFrequencyDecibels(lastX, lastY).frequency;
                decibelY = coordinatesToFrequencyDecibels(lastX, lastY).decibels;
                const frequencies = [0, 125, 250, 500, 750, 1000, 1500, 2000, 3000, 4000, 6000, 8000];

                switch (e.key) {
                    case 'ArrowUp':
                        lastY = frequencyDecibelsToCoordinates(frequencyX, decibelY - 5).y;
                        // redrawCanvas();
                        drawReticle();
                        break;
                    case 'ArrowDown':
                        lastY = frequencyDecibelsToCoordinates(frequencyX, decibelY + 5).y;
                        break;
                    case 'ArrowLeft':
                        const leftIndex = frequencies.indexOf(frequencyX) - 1;
                        if (leftIndex >= 0) {
                            lastX = frequencyDecibelsToCoordinates(frequencies[leftIndex], decibelY).x;
                        }
                        break;
                    case 'ArrowRight':
                        const rightIndex = frequencies.indexOf(frequencyX) + 1;
                        if (rightIndex < frequencies.length) {
                            lastX = frequencyDecibelsToCoordinates(frequencies[rightIndex], decibelY).x;
                        }
                        break;
                }
                redrawCanvas();
                updateGrid();
                // drawReticle(); // Redraw the reticle at the new position
            });
            function coordinatesToFrequencyDecibels(x, y) {
                const frequencies = [0, 125, 250, 500, 750, 1000, 1500, 2000, 3000, 4000, 6000, 8000];
                const frequency = frequencies[Math.floor(x / gridSizeX)];
                const decibels = -10 + Math.floor(y / (gridSizeY / 2)) * 5;
                return { frequency, decibels };
            }

            function frequencyDecibelsToCoordinates(frequency, decibels) {
                const frequencies = [0, 125, 250, 500, 750, 1000, 1500, 2000, 3000, 4000, 6000, 8000];
                const x = frequencies.indexOf(frequency) * gridSizeX;
                const y = ((decibels + 10) / 5) * (gridSizeY / 2);
                return { x, y };
            }
            function drawDot(x, y) {
                if (canvasId === 2) {
                    ctx.beginPath();
                    ctx.strokeStyle = dotColor; // Use the current dot color
                    ctx.arc(x, y, dotRadius, 0, Math.PI * 2);
                    ctx.fillStyle = dotColor; // Use the current dot color
                    // ctx.fill();
                    ctx.stroke();
                } else if (canvasId === 1) {
                    ctx.beginPath();
                    ctx.moveTo(x - 10, y - 10);
                    ctx.lineTo(x + 10, y + 10);
                    ctx.moveTo(x + 10, y - 10);
                    ctx.lineTo(x - 10, y + 10);
                    ctx.strokeStyle = dotColor; // Use the current dot color
                    ctx.stroke();
                }
            }

            let score = 0; // Initialize the score

            function placeDot(x, y) {
                // Convert x, y to frequency and decibels
                const frequencies = [0, 125, 250, 500, 750, 1000, 1500, 2000, 3000, 4000, 6000, 8000];
                const frequencyIndex = Math.floor(x / gridSizeX);
                const frequency = frequencies[Math.floor(x / gridSizeX)];
                const decibels = -10 + Math.floor(y / (gridSizeY / 2)) * 5;

                // Filter out dots with the same frequency
                dots = dots.filter(dot => dot.frequency !== frequency);
                // Push the new dot with frequency and decibels
                dots.push({ frequency, decibels });
                // pushDecibelLevelsToDots();
                redrawCanvas();
                updateGrid(); // Redraw the canvas

                // Check if the placed dot matches any of the random decibel levels
                if (randomDecibelLevels[frequencyIndex] === decibels && Number(document.getElementById('lastCanvas').value) === canvasId) {
                    score += 1000; // Increase the score by 1000
                } else if (randomDecibelLevels[frequencyIndex] !== decibels && Number(document.getElementById('lastCanvas').value) === canvasId) {
                    score -= 5000;
                }
                document.getElementById(`scoreDisplay${canvasId}`).textContent = `Score: ${score}`; // Update the score display
                checkAllDotsMatch(); // Check if all dots match the random decibel levels
            }
            function checkAllDotsMatch() {
                const frequenciesToCheck = [250, 500, 750, 1000, 1500, 2000, 3000, 4000, 6000, 8000];
                const frequencies = [0, 125, 250, 500, 750, 1000, 1500, 2000, 3000, 4000, 6000, 8000];
                const frequencyIndexesToCheck = frequenciesToCheck.map(frequency => frequencies.indexOf(frequency));
                let allMatch = true;
            
                for (let i = 0; i < frequencyIndexesToCheck.length; i++) {
                    const frequencyIndex = frequencyIndexesToCheck[i];
                    const dot = dots.find(dot => dot.frequency === frequencies[frequencyIndex]);
                    if (!dot || dot.decibels !== randomDecibelLevels[frequencyIndex]) {
                        allMatch = false;
                        break;
                    }
                }
            
                if (allMatch) {
                    dots = [];
                    console.log(dots);
                    alert('Congrats!');
                    document.getElementById(`randomButton${canvasId}`).click();
                    redrawCanvas();
                    updateGrid();
                }
            }
            function removeDot(index) {
                dots.splice(index, 1); // Remove the dot from the array
                redrawCanvas()
                updateGrid(); // Redraw the canvas
            }
            function updateGrid() {
                gridSizeX = canvas.width / numSquaresX;
                gridSizeY = canvas.height / numSquaresY;
                redrawCanvas(gridSizeX, gridSizeY);
            }
            let lastClickTime = 0;
            const doubleClickDelay = 200; // Time in milliseconds
            let tempX;
            var shouldContinue;
            let clickCount = 0;

            const decibelIndicator = document.getElementById(`decibelIndicator${canvasId}`);
            let indicatorInterval;

            let randomDecibelLevels = [];
            function generateRandomDecibelLevels() {
                const frequencies = [0, 125, 250, 500, 750, 1000, 1500, 2000, 3000, 4000, 6000, 8000];
                let previousDecibelValue = null;
                randomDecibelLevels = frequencies.map((frequency) => {
                    let decibelValue;
                    if (frequency <= 2000) {
                        if (previousDecibelValue !== null) {
                            // With 60% chance, generate a value within +/- 15 dB of the previous value
                            decibelValue = previousDecibelValue + (Math.floor(Math.random() * 7) - 3) * 5; // -15 to +15 dB in steps of 5
                            // Ensure decibelValue is within the allowed range
                            decibelValue = Math.max(5, Math.min(115, decibelValue));
                        }
                        if (decibelValue === undefined || Math.random() >= 0.72) {
                            // Generate a completely random value if it's the first value or with 40% chance
                            const randomValue = Math.random();
                            if (randomValue < 0.75) { // 60% chance for 5 to 40
                                decibelValue = 5 + Math.floor(Math.random() * ((40 - 5) / 5 + 1)) * 5;
                            } else if (randomValue < 0.88) { // 30% chance for 40 to 60
                                decibelValue = 40 + Math.floor(Math.random() * ((60 - 40) / 5 + 1)) * 5;
                            } else if (randomValue < 0.96) { // 5% chance for 60 to 80
                                decibelValue = 60 + Math.floor(Math.random() * ((80 - 60) / 5 + 1)) * 5;
                            } else { // 5% chance for 80 to 115
                                decibelValue = 80 + Math.floor(Math.random() * ((115 - 80) / 5 + 1)) * 5;
                            }
                        }
                    } else {
                        const randomValue = Math.random();
                        if (randomValue < 0.35) { // 60% chance for 5 to 40
                            decibelValue = 5 + Math.floor(Math.random() * ((40 - 5) / 5 + 1)) * 5;
                        } else if (randomValue < 0.70) { // 30% chance for 40 to 60
                            decibelValue = 40 + Math.floor(Math.random() * ((60 - 40) / 5 + 1)) * 5;
                        } else if (randomValue < 0.93) { // 5% chance for 60 to 80
                            decibelValue = 60 + Math.floor(Math.random() * ((80 - 60) / 5 + 1)) * 5;
                        } else { // 5% chance for 80 to 115
                            decibelValue = 80 + Math.floor(Math.random() * ((115 - 80) / 5 + 1)) * 5;
                        }
                    }
                    previousDecibelValue = decibelValue;
                    return decibelValue;
                });
            }
            document.getElementById(`randomButton${canvasId}`).addEventListener('click', function () {
                generateRandomDecibelLevels();
                console.log("Random decibel levels generated for each frequency:", randomDecibelLevels);
                // You can add any additional actions here, such as updating the UI
            });
            document.getElementById("drawAudiogram").addEventListener('click', function () {
                pushDecibelLevelsToDots();
            });
            document.getElementById(`randomButton${canvasId}`).addEventListener('touchend', function () {
                generateRandomDecibelLevels();
                console.log("Random decibel levels generated for each frequency:", randomDecibelLevels);
                // You can add any additional actions here, such as updating the UI
            });
            function handleCanvasInteraction(e, eventType) {
                lastCanvas = canvasId;
                const rect = canvas.getBoundingClientRect();
                const mouseX = (eventType === 'mousedown' ? e.clientX : e.touches[0].clientX) - rect.left;
                const mouseY = (eventType === 'mousedown' ? e.clientY : e.touches[0].clientY) - rect.top;

                const gridY = Math.round(mouseY / (gridSizeY / 2)) * (gridSizeY / 2);
                const decibelIndex = gridY / (gridSizeY / 2);
                const decibelLevel = -10 + decibelIndex * 5;

                const gridX = Math.round(mouseX / gridSizeX) * gridSizeX;
                const frequencyIndex = Math.floor(gridX / gridSizeX);

                const randomChance = Math.random();

                if (randomDecibelLevels[frequencyIndex] <= decibelLevel || randomChance < 0.1) {
                    document.getElementById(`randomButton${canvasId}`).classList.add('lightUp');
                } else {
                    document.getElementById(`randomButton${canvasId}`).classList.remove('lightUp');
                }
                if (tempX) {
                    redrawCanvas(gridSizeX, gridSizeY); // Redraw the canvas to clear the previous temporary X
                }
                tempX = { x: gridX, y: gridY };
                shouldContinue = true;
                holdStart = Date.now();

                holdTimeout = setTimeout(() => {

                    flashInterval = setInterval(() => {

                        drawTemporaryX(gridX, gridY);
                        if (!shouldContinue) {
                            clearInterval(flashInterval);
                        };
                    }, 300);
                }, 20);

                const frequency = getFrequency(frequencyIndex);
                playSound(frequency);

                beepInterval = setInterval(() => {
                    playSound(frequency);
                }, 650);

                decibelIndicator.classList.add('flashing');
                decibelIndicator.textContent = `Decibel Level: ${decibelLevel}dB`;

                indicatorInterval = setInterval(() => {
                    updateDecibelIndicator(eventType, e);
                }, 500);

                clickCount++;
                lastY = gridY;
                lastX = gridX;
                document.getElementById('lastCanvas').value = canvasId;
                setTimeout(() => {
                    if (clickCount >= 2) {
                        const frequencies = [0, 125, 250, 500, 750, 1000, 1500, 2000, 3000, 4000, 6000, 8000];
                        const frequency = frequencies[frequencyIndex];
                        const decibels = -10 + Math.floor(gridY / (gridSizeY / 2)) * 5;

                        const dotIndex = dots.findIndex(dot => dot.frequency === frequency && dot.decibels === decibels);
                        if (dotIndex !== -1) {
                            removeDot(dotIndex);
                        } else {
                            placeDot(gridX, gridY);
                        }
                    }
                    clickCount = 0;
                }, doubleClickDelay);
            }
            canvas.addEventListener('mousedown', function (e) {
                handleCanvasInteraction(e, 'mousedown');
            });

            canvas.addEventListener('touchstart', function (e) {
                handleCanvasInteraction(e, 'touchstart');
            });

            function drawTemporaryX(gridX, gridY) {
                keepX = setTimeout(() => {
                    if (shouldContinue)
                        redrawCanvas(gridSizeX, gridSizeY);
                    if (!shouldContinue) {
                        // redrawCanvas(gridSizeX, gridSizeY);
                    }
                }, 100);

                drawReticle();

                //     keepX = setTimeout(() => {
                //         if(shouldContinue)
                //         redrawCanvas(gridSizeX, gridSizeY);
                // }, 100);
            }

            function getFrequency(frequencyIndex) {
                const frequencies = [0, 125, 250, 500, 750, 1000, 1500, 2000, 3000, 4000, 6000, 8000];
                return frequencies[frequencyIndex] || 440;
            }

            function playSound(frequency) {
                oscillator = audioCtx.createOscillator();
                gainNode = audioCtx.createGain();

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.2);
            }

            function updateDecibelIndicator(eventType, e) {
                const rect = canvas.getBoundingClientRect();
                const mouseY = (eventType === 'mousedown' ? e.clientY : e.touches[0].clientY) - rect.top;

                const gridY = Math.round(mouseY / (gridSizeY / 2)) * (gridSizeY / 2);
                const decibelIndex = gridY / (gridSizeY / 2);
                const decibelLevel = -10 + decibelIndex * 5;

                decibelIndicator.textContent = `Decibel Level: ${decibelLevel}dB`;
            }

            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            let oscillator;
            let gainNode;
            let beepInterval;

            function pushDecibelLevelsToDots() {
                const frequencies = [0, 125, 250, 500, 750, 1000, 1500, 2000, 3000, 4000, 6000, 8000];;
                dots = randomDecibelLevels.map((decibel, index) => {
                    return {
                        frequency: frequencies[index],
                        decibels: decibel

                    };
                });
            }

            canvas.addEventListener('mouseup', function (e) {

                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                shouldContinue = false;
                // Check if the mouse is still over the canvas
                // if (mouseX >= 0 && mouseX <= canvas.width && mouseY >= 0 && mouseY <= canvas.height) {
                decibelIndicator.classList.remove('flashing');
                clearInterval(indicatorInterval);
                // }
                // Remove the lightUp class after 100ms
                setTimeout(() => {
                    document.getElementById(`randomButton${canvasId}`).classList.remove('lightUp');
                }, 100);
                clearInterval(beepInterval); // Stop the beeping
                if (oscillator) {
                    oscillator.disconnect();
                }
                clearTimeout(holdTimeout);
                clearInterval(flashInterval);
                // if (tempX) {
                //     // Stop flashing
                //     clearInterval(flashInterval);
                //     flashInterval = null;

                //     // Clear the timeout if the mouse was released before 20ms
                //     clearTimeout(holdTimeout);

                //     // // Redraw the canvas to clear the temporary X
                //     // redrawCanvas(gridSizeX, gridSizeY);
                //     // tempX = null;
                // }
            });
            canvas.addEventListener('touchend', function (e) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.changedTouches[0];
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                // Check if the touch is still over the canvas
                // if (touchX >= 0 && touchX <= canvas.width && touchY >= 0 && touchY <= canvas.height) {
                decibelIndicator.classList.remove('flashing');
                clearInterval(indicatorInterval);
                // }

                // Remove the lightUp class after 100ms
                setTimeout(() => {
                    document.getElementById(`randomButton`).classList.remove('lightUp');
                }, 100);
                clearInterval(beepInterval);
                beepInterval = null;
                if (oscillator) {
                    oscillator.stop();
                    oscillator.disconnect();
                }
                clearTimeout(holdTimeout);
                clearInterval(flashInterval);
                // if (tempX) {
                //     // Stop flashing
                //     clearInterval(flashInterval);
                //     flashInterval = null;

                //     // Clear the timeout if the mouse was released before 20ms
                //     clearTimeout(holdTimeout);

                //     // // Redraw the canvas to clear the temporary X
                //     // redrawCanvas(gridSizeX, gridSizeY);
                //     // tempX = null;
                // }
            });
            document.getElementById(`randomButton${canvasId}`).click();
            let oldGridSizeX = gridSizeX; // Keep track of the old grid size
            let oldGridSizeY = gridSizeY; // Keep track of the old grid size

            window.addEventListener('resize', function () {
                canvas.width = window.innerWidth / 4;
                canvas.height = window.innerHeight * .8;

                gridSizeX = canvas.width / numSquaresX;
                gridSizeY = canvas.height / numSquaresY;

                dots.forEach((dot, index) => {
                    dot.x = Math.round(dot.x / oldGridSizeX) * gridSizeX;
                    dot.y = Math.round(dot.y / (oldGridSizeY / 2)) * (gridSizeY / 2);
                });

                redrawCanvas(gridSizeX, gridSizeY);
                updateGrid();

                oldGridSizeX = gridSizeX;
                oldGridSizeY = gridSizeY;
            });

            let activated;
            // Add event listener for spacebar keydown
            document.addEventListener('keydown', function (event) {
                if (event.key === 's') {
                    // Assuming placeDot function exists and takes x, y coordinates
                    // and lastFrequencyIndex and lastDecibelLevel are stored globally
                    const x = lastX;
                    const y = lastY;
                    placeDot(x, y);
                }
                if (event.key === ' ') { // Check if the pressed key is the spacebar
                    // Create oscillator and gain node
                    if(canvasId != lastCanvas)
                    {
                        return;
                    }
                    if (activated) return;
                    activated = 1;
                    const gridY = lastY; // Updated for 5db increments
                    const decibelIndex = gridY / (gridSizeY / 2);
                    const decibelLevel = -10 + decibelIndex * 5; // Updated for 5db increments

                    const gridX = lastX;
                    const frequencyIndex = Math.round(gridX / gridSizeX);

                    // Generate a random number between 0 and 1
                    const randomChance = Math.random();

                    // Check if the decibel level matches or if the random chance is less than 0.1 (10%)
                    if (randomDecibelLevels[frequencyIndex] <= decibelLevel || randomChance < 0.1) {
                        document.getElementById(`randomButton${canvasId}`).classList.add('lightUp');
                    } else {
                        document.getElementById(`randomButton${canvasId}`).classList.remove('lightUp');
                    }
                    oscillator = audioCtx.createOscillator();
                    gainNode = audioCtx.createGain();

                    // Set oscillator properties
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(getFrequency(frequencyIndex), audioCtx.currentTime);
                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);

                    // Start playing the sound
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.2);
                    // Continuously play the sound
                    beepInterval = setInterval(() => {
                        playSound(getFrequency(frequencyIndex));
                    }, 650); // Beep every half second
                }
            });

            // Add event listener for spacebar keyup
            document.addEventListener('keyup', function (event) {
                if(canvasId != lastCanvas)
                    {
                        return;
                    }
                if (event.key === ' ') { // Check if the released key is the spacebar
                    // Stop playing the sound
                    activated = 0;
                    clearInterval(beepInterval);
                    oscillator.stop();
                }
            });

            // Function to get frequency based on lastX (replace with your logic)
            function getFrequency() {
                const frequencies = [0, 125, 250, 500, 750, 1000, 1500, 2000, 3000, 4000, 6000, 8000];
                const frequencyIndex = lastX / gridSizeX;
                return frequencies[frequencyIndex] || 440; // Default to A4 if out of bounds
            }
        }
    </script>
</body>

</html>